<?php
// $Id$

/**
 * @file
 * Test cases for the interlink module.
 */

/**
 * Interlink filter test cases.
 */
class InterLinkFilterTestCase extends DrupalWebTestCase {
  /**
   * Implementation of getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => 'Interlinking contents',
      'description' => 'Verify that interlink properly links terms.',
      'group' => 'Interlink',
    );
  }

  /**
   * Implementation of setUp().
   */
  function setUp() {
    parent::setUp('interlink', 'simplehtmldom');

    // Create and login user.
    $admin_user = $this->drupalCreateUser(array('administer filters', 'create page content'));
    $this->drupalLogin($admin_user);

    // Add an interlink-enabled input format.
    // Find a non-existent random name.
    do {
      $name = strtolower($this->randomName(3, 'inputformat_'));
    } while (filter_format_load($name));
    $edit = array(
      'name' => $name,
      'roles[' . DRUPAL_ANONYMOUS_RID . ']' => TRUE,
      'roles[' . DRUPAL_AUTHENTICATED_RID . ']' => TRUE,
      'filters[interlink/0]' => TRUE,
    );
    $this->drupalPost('admin/settings/filters/add', $edit, t('Save configuration'));
    // Store the format id of the created input format.
    $this->format_id = db_result(db_query("SELECT format FROM {filter_formats} WHERE name = '%s'", $name));
    $this->assertTrue($this->format_id, t('Input format id (%format)', array('%format' => $this->format_id)));

    // Configure filter settings.
    // Add ABBR to allowed tags.
    $edit = array(
      'allowed_html_' . $this->format_id => '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd> <abbr>',
    );
    $this->drupalPost('admin/settings/filters/' . $this->format_id . '/configure', $edit, t('Save configuration'));
  }

  /**
   * Test interlinking contents.
   */
  function testInterlinkContents() {
    // Create a glossary node with two terms.
    $settings = array(
      'type' => 'page',
      'interlink' => array(
        'abbreviations' => implode("\n", array('simple', 'plural form', 'connected', 'excluded', 'abbr within anchor')),
        'synonyms' => 'synonym within anchor',
      ),
    );
    $this->linked_node = $this->drupalCreateNode($settings);

    // Create an interlink-enabed node.
    $settings = array(
      'type' => 'page',
      'format' => $this->format_id,
      'body' => implode("\n", array(
        // Simple term must match.
        '1. simple',
        // Repeated term must not match again.
        '1.1. simple again',
        // Plural form must match.
        '2. plural forms',
        // Part of a connected word must match.
        '3. word-connected',
        // Within excluded parent tags must NOT match.
        '4. <abbr>excluded</abbr>',
        // Abbreviation within existing anchor tag must not create a link.
        '4.1. <a><strong>abbr within anchor is ok</strong></a>',
        // Synonym within existing anchor tag must change anything.
        '4.2. <a>synonym within anchor is not ok</a>',
      )),
    );
    $test_node = $this->drupalCreateNode($settings);

    // Fetch test page.
    $this->drupalGet('node/' . $test_node->nid);

    // Check for expected output.
    $this->assertPattern('@1. '. $this->_createInterlinkPattern(INTERLINK_TYPE_ABBREVIATION, 'simple') . '@', t('Simple term'));
    $this->assertRaw('1.1. simple again', t('Repeated term'));
    $this->assertPattern('@2\. '. $this->_createInterlinkPattern(INTERLINK_TYPE_ABBREVIATION, 'plural form') . 's@', t('Plural form'));
    $this->assertPattern('@3\. word-'. $this->_createInterlinkPattern(INTERLINK_TYPE_ABBREVIATION, 'connected') . '@', t('Connected terms'));
    $this->assertRaw('4. <abbr>excluded</abbr>', t('Term within excluded parent tag'));
    $this->assertPattern('@4\.1\. <a><strong>'. $this->_createInterlinkPattern(INTERLINK_TYPE_ABBREVIATION, 'abbr within anchor', FALSE) . ' is ok</strong></a>@', t('Abbreviation within existing anchor tag'));
    $this->assertRaw('4.2. <a>synonym within anchor is not ok</a>', t('Synonym within existing anchor tag'));
  }

  /**
   * Create a regex pattern to match a linked term.
   *
   * @param $term
   *   The term to match.
   * @param $in_anchor
   *   Whether to link to the term's node.
   */
  protected function _createInterlinkPattern($type, $term, $link = TRUE) {
    $regex = $term;
    if ($type == INTERLINK_TYPE_ABBREVIATION) {
      $regex = '<abbr[^>]+title="' . check_plain($this->linked_node->title) . '"[^>]*>' . $regex . '</abbr>';
    }
    if ($link) {
      $regex = '<a[^>]+href="' . url('node/' . $this->linked_node->nid) . '[^"]*"[^>]*>' . $regex . '</a>';
    }
    return $regex;
  }
}

